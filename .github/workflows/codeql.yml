# .github/workflows/custom-codeql.yml
# 描述: 為大量獨立 C 檔案設計的自訂 CodeQL 工作流程。
# 目的: 解決預設 CodeQL 分析因檔案過多而中斷的問題。
# 版本: v3 - 修正並簡化了建構指令，使其更穩定、更標準。

name: "Custom CodeQL Analysis for C/C++"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  analyze:
    name: Analyze C/C++ Code
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false

    steps:
    # 步驟 1: 將您的倉庫程式碼下載到虛擬環境中
    - name: Checkout repository
      uses: actions/checkout@v4

    # 步驟 2: 初始化 CodeQL
    # CodeQL 會自動準備好，並追蹤後續步驟中的編譯指令。
    # 我們不再需要 build-mode: none 這個複雜的設定。
    - name: Initialize CodeQL
      uses: codeql-action/init@v3
      with:
        languages: cpp

    # 步驟 3: 編譯所有 C 檔案 (關鍵步驟)
    # 我們使用一個簡單的迴圈來逐一編譯檔案。
    # CodeQL 的 init 步驟會自動"看見"並追蹤這個 run 步驟中的 gcc 指令來建立資料庫。
    - name: Compile all C files for analysis
      run: |
        find ./vulnerable_code_base -name "*.c" -print0 | while IFS= read -r -d '' file; do
          echo "Compiling $file for analysis..."
          # 使用 -c 選項只編譯不連結，這是 CodeQL 建立資料庫所需。
          # `|| true` 確保即使有單一檔案編譯失敗，整個工作流程也不會立即中止。
          gcc -c "$file" -o "${file}.o" || true
        done

    # 步驟 4: 執行分析
    # CodeQL 會使用上一步透過追蹤編譯所建立的資料庫來進行分析。
    - name: Perform CodeQL Analysis
      uses: codeql-action/analyze@v3

